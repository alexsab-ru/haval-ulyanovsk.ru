---
interface Props {
	title?: string;
	description?: string;
	keywords?: string;
	goal?: string;
	redirectUrl?: string;
	saveUrl?: string;
	pageText?: string;
	messageToTelegram?: string;
}
let {
	title,
	description,
	keywords,
	goal = 'telegram_redirect',
	redirectUrl = 'https://t.me/alexsab_ru',
	saveUrl = '',
	pageText = 'Вы будете перенаправлены<br/>через 3 секунды...',
	messageToTelegram = 'metrika doesn\'t connect'
} = Astro.props;

import scripts_json from '@/data/scripts.json';
const canonicalURL = new URL(Astro.url.pathname, Astro.url);
---

<!doctype html>
<html lang="ru" class="h-full">
	<head>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width,initial-scale=1" />
		<link rel="icon" type="image/svg+xml" href="/favicon.svg" />

		<!-- Canonical URL -->
		<link rel="canonical" href={canonicalURL} />

		<!-- Primary Meta Tags -->
		<title>{title}</title>
		<meta name="title" content={title} />
		<meta name="description" content={description} />
		{keywords && <meta name="keywords" content={keywords} />}

		<!-- Open Graph -->
		<meta property="og:type" content="website" />
		<meta property="og:url" content={Astro.url} />
		<meta property="og:title" content={title} />
		<meta property="og:description" content={description} />

		<script define:vars={{ scripts_json, goal, redirectUrl, messageToTelegram, saveUrl }}>
			(function() {

				/**
				 * Скачивает файл по ссылке и предлагает «Сохранить как…»
				 * @param {string} url       — абсолютная или относительная ссылка на файл
				 * @param {string} [filename]— имя, показываемое в диалоге (опционально)
				 */
				async function downloadFile(url, filename) {
					// 1. Если имя не задано, извлекаем его из URL
					if (!filename) {
						// URL-парсер надёжно отделит путь от query/hash
						const { pathname } = new URL(url, window.location.href);
						// Берём последний сегмент пути
						const lastSegment = pathname.split('/').pop() || 'download';
						// Декодируем «%D0%A4%D0%B0%D0%B9%D0%BB.pdf» → «Файл.pdf»
						filename = decodeURIComponent(lastSegment);
					}

					// 2. Скачиваем файл и превращаем в Blob
					const response = await fetch(url);
					if (!response.ok) throw new Error(`Не удалось скачать файл: ${response.status}`);
					const blob = await response.blob();

					// 3. Создаём временную ссылку и запускаем «скачивание»
					const tempUrl = URL.createObjectURL(blob);
					const a = Object.assign(document.createElement('a'), {
						href: tempUrl,
						download: filename,
						style: 'display:none'
					});
					document.body.appendChild(a);
					a.click();
					a.remove();
					URL.revokeObjectURL(tempUrl);
				}

				// Яндекс Метрика
				if (scripts_json.metrika && scripts_json.metrika.length > 0) {
					(function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
					m[i].l=1*new Date();
					for (var j = 0; j < document.scripts.length; j++) {if (document.scripts[j].src === r) { return; }}
					k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
					(window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");
					
					scripts_json.metrika.forEach(metrika => {
						ym(metrika.id, "init", metrika);
					});

					var getMetrikaID = function() {
						let metrikaID = (typeof ym != 'undefined' && typeof ym.a != 'undefined') ? ym.a[0][0] : findPropertyByPrefix(window, "yaCounter").substr(9);
						console.log("getMetrikaID:",metrikaID);

						if (metrikaID) {
							setTimeout(function() {
								scripts_json.metrika.forEach(metrika => {
									ym(metrika.id, 'reachGoal', goal, function() {
										console.log('Цель отправлена, выполняем редирект');
										if(saveUrl) {
											downloadFile(saveUrl);
										} else {
											window.location.href = redirectUrl;
										}
									});
								});
								setTimeout(function() {
									fetch('https://alexsab.ru/lead/tg/', {
										method: 'POST',
										body: JSON.stringify({
											message: messageToTelegram,
											goal: goal,
											redirectUrl: redirectUrl,
											saveUrl: saveUrl
										})
									})
									.then((res) => res.json())
									.then((data) => {
										if(saveUrl) {
											downloadFile(saveUrl);
										} else {
											window.location.href = redirectUrl;
										}
									})
									.catch((error) => {
										console.error('Error:', error);
									});
								}, 1000);
							}, 2000);
						}
						return metrikaID;
					},
					findPropertyByPrefix = function(object, prefix) {
						for (var property in object) {
							if (object.hasOwnProperty(property) &&
								property.toString().startsWith(prefix)) {
								console.log("findPropertyByPrefix:",property);
								return property;
							}
						}
						setTimeout(function() {
							metrikaID = getMetrikaID();
							console.log("setTimeout:",metrikaID);
						}, 100);
						return "";
					},
					metrikaID = getMetrikaID();
				}
			})();
		</script>
	</head>
	<body class="h-full flex justify-center items-center">
		<h2 class="font-bold md:text-3xl text-center p-3"><Fragment set:html={pageText} /></h2>
	</body>
</html>
